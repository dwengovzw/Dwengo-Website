---
layout: default
permalink: /bot/
---


<!-- Chat Widget -->
<div id="dwengo-chat-widget">
  <div id="dwengo-chat-header">
    <span class="dwengo-chat-spacer"></span>
    <span class="dwengo-chat-title">{{ site.translations[site.lang].bot.title }}</span>
    <button id="dwengo-chat-expand" aria-label="Expand chat" title="Expand">⤢</button>
  </div>
  <div id="dwengo-chat-messages"></div>
  <div id="dwengo-chat-input">
  <textarea id="dwengo-chat-text" placeholder="{{ site.translations[site.lang].bot.placeholder }}"></textarea>
    <button id="dwengo-chat-send">{{ site.translations[site.lang].bot.send }}</button>
  </div>
</div>

<style>
#dwengo-chat-widget {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 300px;
  max-height: 400px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  font-family: Arial, sans-serif;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  overflow: hidden;
  z-index: 9999;
}
#dwengo-chat-header {
  background: #87C544;
  color: white;
  padding: 10px;
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dwengo-chat-title { flex: 1; text-align: center; }
#dwengo-chat-expand {
  background: rgba(255,255,255,0.15);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 6px;
  font-size: 14px;
  line-height: 1;
  padding: 6px 8px;
  cursor: pointer;
}
#dwengo-chat-expand:hover { background: rgba(255,255,255,0.25); }
#dwengo-chat-messages {
  flex: 1;
  padding: 12px;
  overflow-y: auto;
  font-size: 14px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: #fff;
}
#dwengo-chat-messages .user,
#dwengo-chat-messages .bot {
  position: relative;
  max-width: 85%;
  padding: 10px 12px;
  border-radius: 16px;
  line-height: 1.4;
  box-shadow: 0 1px 2px rgba(0,0,0,0.06);
}
#dwengo-chat-messages .user {
  align-self: flex-end;
  background: #eaf6d9; /* light green */
  border: 1px solid rgba(133,196,65,0.35);
  color: #2f6f1a; /* dark green text */
  text-align: left;
}
#dwengo-chat-messages .bot {
  align-self: flex-start;
  background: #f2f8e9;
  border: 1px solid rgba(133,196,65,0.25);
  color: #2d2d2d;
  white-space: normal; /* Markdown/HTML will control formatting */
}
#dwengo-chat-messages .user::after {
  content: "";
  position: absolute;
  right: -6px;
  bottom: 10px;
  width: 0; height: 0;
  border-style: solid;
  border-width: 6px 0 6px 6px;
  border-color: transparent transparent transparent #eaf6d9;
}
#dwengo-chat-messages .bot::after {
  content: "";
  position: absolute;
  left: -6px;
  bottom: 10px;
  width: 0; height: 0;
  border-style: solid;
  border-width: 6px 6px 6px 0;
  border-color: transparent #f2f8e9 transparent transparent;
}
#dwengo-chat-messages .bot.loading {
  color: #888;
  font-style: italic;
}
/* Link styles inside chat */
#dwengo-chat-messages a {
  color: #85c441;
  text-decoration: underline;
}
#dwengo-chat-messages a:hover { color: #6FA636; }
#dwengo-chat-messages a:active { color: #5A8E2F; }
#dwengo-chat-messages a:visited { color: #6FA636; }
#dwengo-chat-messages pre {
  overflow: auto;
  margin: 8px 0;
}
#dwengo-chat-messages code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.95em;
}
#dwengo-chat-messages pre,
#dwengo-chat-messages pre code {
  white-space: pre-wrap; /* preserve newlines and allow wrapping */
}
#dwengo-chat-input {
  display: flex;
  border-top: 1px solid #ccc;
}
#dwengo-chat-input textarea {
  flex: 1;
  border: none;
  padding: 10px;
  font-size: 14px;
  line-height: 1.35;
  resize: none; /* we'll control size in JS */
  overflow-y: hidden; /* becomes auto when max is hit */
  max-height: 140px; /* reasonable cap */
  min-height: 38px;  /* single-line height */
  height: 38px;      /* start as single line */
  outline: none;
}
#dwengo-chat-input button {
  background: #87C544;
  border: none;
  color: white;
  padding: 0 15px;
  cursor: pointer;
}
#dwengo-chat-input button:hover {
  background: #6FA636;
}

/* Overlay and expanded mode */
#dwengo-chat-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  z-index: 9998;
  display: none;
}
#dwengo-chat-overlay.visible { display: block; }

#dwengo-chat-widget.expanded {
  top: 50%;
  left: 50%;
  right: auto;
  bottom: auto;
  transform: translate(-50%, -50%);
  width: min(720px, 94vw);
  height: 80vh;
  max-height: 80vh;
  border-radius: 16px;
  box-shadow: 0 16px 40px rgba(0,0,0,0.35);
}
body.dwengo-chat-no-scroll { overflow: hidden; }
</style>

<!-- Markdown parser -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<!-- Prettier standalone + plugins (for in-browser code formatting) -->
<script src="https://unpkg.com/prettier@3.3.3/standalone.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/babel.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/estree.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/typescript.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/html.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/postcss.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/markdown.js"></script>
<script src="https://unpkg.com/prettier@3.3.3/plugins/yaml.js"></script>

<script>
const apiUrl = "https://kiks2.ilabt.imec.be/bot/v1/chat"; // adjust if hosted elsewhere
const TYPE_DELAY_MS = 25; // artificial delay per chunk (ms) to simulate typing
const LOADING_TEXT = "{{ site.translations[site.lang].bot.thinking }}"; // placeholder shown while waiting for first tokens

document.getElementById("dwengo-chat-send").addEventListener("click", sendMessage);
const dwengoInput = document.getElementById("dwengo-chat-text");
dwengoInput.addEventListener("keydown", function(e) {
  // Enter sends; Shift+Enter inserts newline
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});
dwengoInput.addEventListener("input", function() {
  autoResize(this);
});
// Initialize height on load
autoResize(dwengoInput);

function autoResize(el) {
  const MAX_HEIGHT = 140;
  el.style.height = "auto";
  const newH = Math.min(el.scrollHeight, MAX_HEIGHT);
  el.style.height = newH + "px";
  el.style.overflowY = el.scrollHeight > MAX_HEIGHT ? "auto" : "hidden";
}

// Expand/Collapse logic
const widget = document.getElementById('dwengo-chat-widget');
const expandBtn = document.getElementById('dwengo-chat-expand');
// Create overlay dynamically so it sits after body
const overlay = document.createElement('div');
overlay.id = 'dwengo-chat-overlay';
document.body.appendChild(overlay);

function isExpanded() { return widget.classList.contains('expanded'); }
function expandChat() {
  widget.classList.add('expanded');
  overlay.classList.add('visible');
  document.body.classList.add('dwengo-chat-no-scroll');
  expandBtn.textContent = '⤡';
  expandBtn.title = 'Close';
  expandBtn.setAttribute('aria-label', 'Close chat');
  // Keep focus on input for quick typing
  dwengoInput.focus();
}
function collapseChat() {
  widget.classList.remove('expanded');
  overlay.classList.remove('visible');
  document.body.classList.remove('dwengo-chat-no-scroll');
  expandBtn.textContent = '⤢';
  expandBtn.title = 'Expand';
  expandBtn.setAttribute('aria-label', 'Expand chat');
}
expandBtn.addEventListener('click', () => {
  isExpanded() ? collapseChat() : expandChat();
});
overlay.addEventListener('click', collapseChat);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && isExpanded()) collapseChat();
});

async function sendMessage() {
  const input = document.getElementById("dwengo-chat-text");
  const message = input.value.trim();
  if (!message) return;

  appendMessage("user", message);
  input.value = "";
  // Reset input back to single line
  input.style.height = "38px";
  input.style.overflowY = "hidden";

  // Create a placeholder for streaming response
  const botMsgElem = appendMessage("bot", LOADING_TEXT);
  botMsgElem.classList.add("loading");

  // Simple per-message typing queue to control render speed
  let started = false; // becomes true when first token arrives
  const queue = [];
  let typing = false;
  let renderTimer = null;
  let rawBotText = ""; // accumulate raw text for markdown rendering

  function renderCurrent() {
    try {
      if (window.marked && typeof marked.parse === 'function') {
        if (marked.setOptions) {
          marked.setOptions({ gfm: true, breaks: true, mangle: false, headerIds: false });
        }
        // Debug logging: raw and processed content
        //console.log('[CHAT][RAW]', rawBotText);
        const sanitized = sanitizeMarkdown(rawBotText);
        const processedHtml = marked.parse(sanitized);
        //console.log('[CHAT][HTML]', processedHtml);
        botMsgElem.innerHTML = processedHtml;
      } else {
        //console.log('[CHAT][RAW]', rawBotText);
        //console.log('[CHAT][TEXT]', rawBotText);
        botMsgElem.textContent = rawBotText;
      }
    } catch (_) {
      //console.log('[CHAT][RAW]', rawBotText);
      //console.log('[CHAT][TEXT-FALLBACK]', rawBotText);
      botMsgElem.textContent = rawBotText;
    }
  // Auto-format code in supported languages (Prettier), then highlight and typeset
  formatCodeBlocks(botMsgElem);
  highlightCode(botMsgElem);
    typesetMath(botMsgElem);
  }

  function scheduleRenderDebounced() {
    clearTimeout(renderTimer);
    renderTimer = setTimeout(renderCurrent, 200);
  }

  function enqueue(token) {
    if (!token) return;
    if (!started) {
      // First token: clear placeholder and switch to normal style
      botMsgElem.textContent = "";
      botMsgElem.classList.remove("loading");
      started = true;
    }

    //console.log("Queuing token: " + token);
    queue.push(token);
    if (!typing) processQueue();
  }

  async function processQueue() {
    typing = true;
    while (queue.length) {
      const chunk = queue.shift();
      // Add a small delay so it looks like the text is being written
      await new Promise(res => setTimeout(res, TYPE_DELAY_MS));
      
      rawBotText += chunk;
      //console.log("Raw bot text: " + rawBotText);
      renderCurrent();
      scrollMessages();
      scheduleRenderDebounced();
    }
    typing = false;
  }

  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
        "DWENGO-API-KEY": "MBIyVRAQ2cwkeYmyMtlEgZqcuqefB1wgQXftC8G06DWrunbrFILK6thzqgGw6AEXyg5loNG7yTeR4EjrTgB19K4ewuBaDlLFJWoGnLVGiHmLpTfTiSusHeqQWiCGi9DE" // adjust if required
      },
      body: JSON.stringify({ query: message, stream: true })
    });

    if (!response.ok || !response.body) {
      botMsgElem.textContent = "Error connecting to server.";
      botMsgElem.classList.remove("loading");
      return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        let parts = buffer.split("data: ");
        console.log(`parts: ${parts}`);
        


        // Look if there are more than 2 consecuative \n characters in the part. If there are, remove two \n characters from that consecuative sequence.
        parts = parts.map(part => part.replace(/(\n\n)+/g, "\n"));

        // Replace all \n\n with empty string in parts
        //parts.forEach((part, index) => {
        //    parts[index] = part.replace(/\n\n/g, "");
        //});
//
        // Remove all parts with empty string
        parts = parts.filter(part => part !== "");

        // apply cleanBotText to each part
        parts = parts.map(part => cleanBotText(part));

        // Enqueue each part
        for (const part of parts){
            enqueue(part);
        }
  }

  // Ensure final render/typeset when stream completes
  renderCurrent();

    // If stream ended but no content arrived, replace placeholder with message
    if (!started) {
      botMsgElem.textContent = "No response from server.";
      botMsgElem.classList.remove("loading");
    }
  } catch (err) {
    botMsgElem.textContent = "Error fetching response.";
    botMsgElem.classList.remove("loading");
    console.error(err);
  }
}

function cleanBotText(text) {
  // Remove system/user tags
  text = text.replace(/<\|\/?(user|system)\|>/g, "");

  return text;
}

function appendMessage(sender, text, isHtml = false) {
  const messagesDiv = document.getElementById("dwengo-chat-messages");
  const msg = document.createElement("div");
  msg.className = sender;
  
  if (isHtml) {
    msg.innerHTML = text;
  } else {
    msg.textContent = text;
  }

  messagesDiv.appendChild(msg);
  scrollMessages();
  return msg; // return the element so we can update it while streaming
}

function scrollMessages() {
  const messagesDiv = document.getElementById("dwengo-chat-messages");
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Normalize code fences like ```python<no-newline> to ```python\n
function sanitizeMarkdown(raw) {
  try {
    const langs = [
      'python','py','javascript','js','typescript','ts','java','c','cpp','c\\+\\+','csharp','c#','cs','go','rust','rs',
      'bash','sh','shell','zsh','powershell','ps1','html','xml','css','json','yaml','yml','markdown','md','sql','swift',
      'kotlin','r','julia','php','ruby','rb','matlab','octave','scala','dart','haskell','hs','lua','perl','pl',
      'objective-c','objc','ocaml','elixir','erlang','solidity','proto','protobuf','dockerfile','makefile','gradle',
      'groovy','ini','toml','tex','latex','vhdl','verilog'
    ];
    const pattern = new RegExp("```[ \t]*(" + langs.join('|') + ")\\b(?![ \t]*\\n)", 'gi');
    // Insert a newline after the language if one is not present
    raw = raw.replace(pattern, (m, lang) => {
      return '```' + String(lang).toLowerCase() + '```\n';
    });
    // Ensure a newline after closing fences like ``` when not followed by a newline
    raw = raw.replace(/```(?![a-zA-Z])(?=[^\n])/g, '\n```\n');
    // If the content ends with a closing fence without newline, append one
    if (/(^|\n)```[ \t]*$/.test(raw)) raw += '\n';
        return raw;
    } catch (_) {
        return raw;
    }
}

// MathJax typesetting helper (supports v2 and v3)
function typesetMath(el, retries = 5) {
  try {
    if (window.MathJax) {
      // v3 preferred
      if (typeof MathJax.typesetPromise === 'function') {
        return MathJax.typesetPromise([el]).catch(() => {});
      }
      // v2 fallback
      if (MathJax.Hub && typeof MathJax.Hub.Queue === 'function') {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, el]);
        return;
      }
    }
  } catch (_) {}
  if (retries > 0) {
    setTimeout(() => typesetMath(el, retries - 1), 400);
  }
}

// Prism highlighting helper
function highlightCode(el) {
  try {
    if (window.Prism) {
      if (typeof Prism.highlightAllUnder === 'function') {
        Prism.highlightAllUnder(el);
        return;
      }
      if (typeof Prism.highlightElement === 'function') {
        const nodes = el.querySelectorAll('pre code, code[class*="language-"]');
        nodes.forEach(n => Prism.highlightElement(n));
      }
    }
  } catch (_) {}
}

// Prettier formatting helper (best-effort; skips unsupported languages)
function formatCodeBlocks(el) {
  try {
    if (!window.prettier || !window.prettierPlugins) return;
    const codeNodes = el.querySelectorAll('pre code');
    codeNodes.forEach((node) => {
      const cls = node.className || '';
      const langMatch = cls.match(/language-([a-z0-9+#-]+)/i);
      const lang = langMatch ? langMatch[1].toLowerCase() : '';
      let parser = null;
      switch (lang) {
        case 'js':
        case 'jsx':
        case 'javascript':
          parser = 'babel';
          break;
        case 'ts':
        case 'tsx':
        case 'typescript':
          parser = 'typescript';
          break;
        case 'json':
          parser = 'json';
          break;
        case 'html':
        case 'xml':
          parser = 'html';
          break;
        case 'css':
        case 'scss':
        case 'less':
          parser = 'css';
          break;
        case 'md':
        case 'markdown':
          parser = 'markdown';
          break;
        case 'yaml':
        case 'yml':
          parser = 'yaml';
          break;
        default:
          parser = null; // unsupported (e.g., python, java, etc.)
      }
      if (!parser) return;
      const src = node.textContent;
      try {
        const formatted = prettier.format(src, {
          parser,
          plugins: prettierPlugins,
          tabWidth: 2,
          useTabs: false,
          semi: true,
          singleQuote: false,
          trailingComma: 'es5',
        });
        if (formatted && formatted !== src) {
          node.textContent = formatted;
        }
      } catch (_) {
        // ignore formatting errors
      }
    });
  } catch (_) {}
}
</script>
